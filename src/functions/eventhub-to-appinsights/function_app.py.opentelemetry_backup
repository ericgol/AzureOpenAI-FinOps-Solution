"""
EventHub to Application Insights Telemetry Forwarder

Azure Function using Python v2 programming model that receives telemetry events from EventHub 
(originated from APIM policy) and forwards them to Application Insights for analysis and 
correlation with cost data.

The function processes batches of events from EventHub and sends them to Application Insights
as structured trace telemetry with all the custom properties needed for FinOps analysis.

Author: FinOps Team
"""

import logging
import json
import os
from typing import List, Dict, Any, Optional
from datetime import datetime, timezone

import azure.functions as func
from applicationinsights import TelemetryClient
from applicationinsights.channel import TelemetryChannel
from applicationinsights.channel import SynchronousSender, SynchronousQueue

# Initialize function app
app = func.FunctionApp()

# Global Application Insights telemetry client (initialized once, reused across invocations)
_telemetry_client: Optional[TelemetryClient] = None


def get_or_create_telemetry_client() -> TelemetryClient:
    """
    Get or create Application Insights TelemetryClient.
    
    This function implements a singleton pattern to avoid reinitializing
    the client on every function invocation (Python v2 best practice).
    
    Returns:
        TelemetryClient: Configured Application Insights client
        
    Raises:
        ValueError: If APPLICATIONINSIGHTS_CONNECTION_STRING is not configured
    """
    global _telemetry_client
    
    # Return cached instance if already initialized
    if _telemetry_client is not None:
        return _telemetry_client
    
    connection_string = os.environ.get('APPLICATIONINSIGHTS_CONNECTION_STRING')
    if not connection_string:
        raise ValueError("APPLICATIONINSIGHTS_CONNECTION_STRING environment variable is required")
    
    # Extract instrumentation key from connection string
    # Format: InstrumentationKey=xxx;IngestionEndpoint=https://...;
    instrumentation_key = None
    for part in connection_string.split(';'):
        if part.startswith('InstrumentationKey='):
            instrumentation_key = part.split('=', 1)[1]
            break
    
    if not instrumentation_key:
        raise ValueError("Could not extract InstrumentationKey from APPLICATIONINSIGHTS_CONNECTION_STRING")
    
    # Create telemetry client with synchronous channel for immediate sending
    sender = SynchronousSender()
    queue = SynchronousQueue(sender)
    channel = TelemetryChannel(None, queue)
    _telemetry_client = TelemetryClient(instrumentation_key, telemetry_channel=channel)
    
    # Set cloud role name
    _telemetry_client.context.cloud.role = "eventhub-to-appinsights"
    _telemetry_client.context.cloud.role_instance = os.environ.get('WEBSITE_INSTANCE_ID', 'local')
    
    logging.info("Application Insights TelemetryClient initialized successfully")
    
    return _telemetry_client


def parse_telemetry_event(event_data: str) -> Optional[Dict[str, Any]]:
    """
    Parse and validate telemetry event from EventHub.
    
    Args:
        event_data: Raw event data string from EventHub
        
    Returns:
        Parsed telemetry data or None if parsing fails
    """
    try:
        data = json.loads(event_data)
        
        # Validate required fields
        if not isinstance(data, dict):
            logging.warning(f"Invalid event data format: expected dict, got {type(data)}")
            return None
            
        # Extract and validate event type
        event_type = data.get('eventType')
        if event_type not in ['FinOpsApiCall', 'FinOpsApiError']:
            logging.warning(f"Unknown event type: {event_type}")
            return None
            
        return data
        
    except json.JSONDecodeError as e:
        logging.error(f"Failed to parse JSON event data: {e}")
        return None
    except Exception as e:
        logging.error(f"Unexpected error parsing event data: {e}")
        return None


def create_span_attributes(telemetry_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create OpenTelemetry span attributes from parsed event data.
    
    Args:
        telemetry_data: Parsed telemetry data from EventHub
        
    Returns:
        Dictionary with span attributes for OpenTelemetry
    """
    event_type = telemetry_data.get('eventType', 'Unknown')
    
    # Core FinOps attributes for cost analysis
    # Field names match what APIM policy sends
    attributes = {
        'event.type': event_type,
        'correlation.id': telemetry_data.get('correlationId', ''),
        'device.id': telemetry_data.get('deviceId', 'unknown'),
        'store.number': telemetry_data.get('storeNumber', 'unknown'),
        'api.name': telemetry_data.get('apiName', ''),
        'operation.name': telemetry_data.get('operationName', ''),
        'http.method': telemetry_data.get('method', ''),
        'http.url': telemetry_data.get('url', ''),
        'http.status_code': telemetry_data.get('statusCode', 0),
        'http.response_time_ms': telemetry_data.get('responseTime', 0),
        'ai.tokens.used': telemetry_data.get('tokensUsed', 0),
        'ai.tokens.prompt': telemetry_data.get('promptTokens', 0),
        'ai.tokens.completion': telemetry_data.get('completionTokens', 0),
        'ai.model.name': telemetry_data.get('model', ''),  # APIM sends 'model' not 'modelName'
        'api.version': telemetry_data.get('apiVersion', ''),
        'deployment.id': telemetry_data.get('deploymentId', ''),
        'subscription.id': telemetry_data.get('subscriptionId', ''),
        'product.id': telemetry_data.get('productId', ''),
        'resource.region': telemetry_data.get('resourceRegion', ''),
        'timestamp': telemetry_data.get('timestamp', '')
    }
    
    # Add error-specific attributes if present
    if event_type == 'FinOpsApiError':
        attributes.update({
            'error.message': telemetry_data.get('errorMessage', ''),
            'error.source': telemetry_data.get('errorSource', '')
        })
    
    # Remove empty values to reduce telemetry size and convert to proper types
    cleaned_attributes = {}
    for k, v in attributes.items():
        if v is not None and v != '' and v != 0:
            # Convert numeric strings to appropriate types
            if isinstance(v, str) and v.isdigit():
                cleaned_attributes[k] = int(v)
            elif isinstance(v, str) and v.replace('.', '', 1).isdigit():
                cleaned_attributes[k] = float(v)
            else:
                cleaned_attributes[k] = v
    
    return cleaned_attributes


@app.function_name(name="eventhub_to_appinsights")
@app.event_hub_message_trigger(
    arg_name="events",
    event_hub_name="%EventHubName%",
    connection="EventHubConnection",
    consumer_group="$Default",
    cardinality=func.Cardinality.MANY,
    data_type=func.DataType.STRING
)
def eventhub_to_appinsights(events: List[func.EventHubEvent]) -> None:
    """
    EventHub-triggered function that forwards telemetry to Application Insights.
    
    This function processes batches of telemetry events from EventHub (sent by APIM policy)
    and forwards them to Application Insights using OpenTelemetry for structured tracing.
    
    Args:
        events: List of EventHub events containing APIM telemetry data
    """
    event_count = len(events)
    logging.info(f'EventHub to AppInsights function triggered with {event_count} events')
    
    if not events:
        logging.info('No events to process')
        return
    
    try:
        # Initialize Application Insights telemetry client (singleton pattern)
        tc = get_or_create_telemetry_client()
        
        processed_count = 0
        error_count = 0
        
        # Process each event in the batch
        for event_index, event in enumerate(events):
            try:
                # Get event body as string
                event_body = event.get_body().decode('utf-8')
                
                # Parse the telemetry event
                parsed_data = parse_telemetry_event(event_body)
                if not parsed_data:
                    error_count += 1
                    continue
                
                # Create attributes from parsed data
                attributes = create_span_attributes(parsed_data)
                event_type = parsed_data.get('eventType', 'Unknown')
                
                # Track as custom event with all attributes as properties
                tc.track_event(
                    name=f"FinOps{event_type}",
                    properties=attributes,
                    measurements={
                        "tokens_used": attributes.get('ai.tokens.used', 0),
                        "prompt_tokens": attributes.get('ai.tokens.prompt', 0),
                        "completion_tokens": attributes.get('ai.tokens.completion', 0),
                        "response_time_ms": attributes.get('http.response_time_ms', 0)
                    }
                )
                
                processed_count += 1
                
                # Log successful processing (only for first few events to avoid log spam)
                if processed_count <= 5:
                    correlation_id = parsed_data.get('correlationId', 'N/A')
                    device_id = parsed_data.get('deviceId', 'unknown')
                    store_number = parsed_data.get('storeNumber', 'unknown')
                    logging.info(f'Processed event - CorrelationId: {correlation_id}, DeviceId: {device_id}, StoreNumber: {store_number}, Attributes: {len(attributes)}')
                
            except Exception as e:
                error_count += 1
                logging.error(f'Error processing individual event: {str(e)}')
                tc.track_exception()
                continue
        
        # Flush telemetry to ensure immediate sending
        tc.flush()
        logging.info(f'Telemetry flushed to Application Insights')
        
        # Track metrics
        tc.track_metric("eventhub.processed_events", processed_count)
        if error_count > 0:
            tc.track_metric("eventhub.processing_errors", error_count)
        
        # Log processing summary
        logging.info(f'Batch processing completed - Processed: {processed_count}, Errors: {error_count}')
        
    except Exception as e:
        logging.error(f'Critical error in EventHub to AppInsights function: {str(e)}', exc_info=True)
        
        # Try to create error span if tracer is available
        try:
            if _tracer is not None:
                with _tracer.start_as_current_span("critical_error") as error_span:
                    error_span.set_status(Status(StatusCode.ERROR, str(e)))
                    error_span.set_attribute("error.type", type(e).__name__)
                    error_span.set_attribute("error.message", str(e))
                    error_span.record_exception(e)
        except Exception:
            pass  # Avoid nested exceptions
        
        raise  # Re-raise to trigger function retry if configured
